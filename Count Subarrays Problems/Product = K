class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        // For exact product = k, we use logarithms to convert to sum problem
        // log(a*b*c) = log(a) + log(b) + log(c)
        
        unordered_map<double, int> logSumFreq;
        logSumFreq[0] = 1;  // log(1) = 0
        
        double logK = log(k);
        double prefixLogSum = 0;
        int count = 0;
        
        for (int num : nums) {
            if (num == 0) {
                // Special handling for 0 (reset prefix)
                prefixLogSum = 0;
                logSumFreq.clear();
                logSumFreq[0] = 1;
                continue;
            }
            
            prefixLogSum += log(num);
            
            // Look for: prefixLogSum - logK
            double target = prefixLogSum - logK;
            
            // Use epsilon for floating point comparison
            for (auto& [key, freq] : logSumFreq) {
                if (abs(key - target) < 1e-9) {
                    count += freq;
                }
            }
            
            logSumFreq[prefixLogSum]++;
        }
        
        return count;
    }
    
    // Alternative: Direct product approach (for smaller values)
    int countSubarraysProductK(vector<int>& nums, int k) {
        int count = 0;
        
        for (int i = 0; i < nums.size(); i++) {
            long long product = 1;
            for (int j = i; j < nums.size(); j++) {
                product *= nums[j];
                if (product == k) count++;
                if (product > k || nums[j] == 0) break;
            }
        }
        
        return count;
    }
};

Example: nums = [2, 1, 3, 4, 1, 2], k = 6
Using direct approach:

Subarray	Product	Valid?
[2,1,3]	6	✓
[3,2]	6	✓ (indices 2,5)
[1,3,2]	6	✓ (indices 4,2,5)
Count = 3
