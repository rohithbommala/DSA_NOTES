class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        unordered_map<int, int> remainderFreq;
        remainderFreq[0] = 1;  // Empty prefix has remainder 0
        
        int prefixSum = 0;
        int count = 0;
        
        for (int num : nums) {
            prefixSum += num;
            
            // Handle negative remainders
            int remainder = ((prefixSum % k) + k) % k;
            
            // Look for: same remainder
            if (remainderFreq.count(remainder)) {
                count += remainderFreq[remainder];
            }
            
            remainderFreq[remainder]++;
        }
        
        return count;
    }
};

Example: nums = [4, 5, 0, -2, -3, 1], k = 5
i	num	prefixSum	remainder	freq[remainder]	count	Update freq	Explanation
0	4	4	4	0	0	freq[4]=1	No match
1	5	9	4	1	1	freq[4]=2	[5] divisible by 5
2	0	9	4	2	3	freq[4]=3	[5,0] and [0]
3	-2	7	2	0	3	freq[2]=1	No match
4	-3	4	4	3	6	freq[4]=4	3 more subarrays
5	1	5	0	1	7	freq[0]=2	Entire array
Found subarrays: [5], [5,0], [0], [5,0,-2,-3], [0,-2,-3], [-2,-3], [4,5,0,-2,-3,1]

Why Same Remainder Works:
text
If prefixSum[j] % k == prefixSum[i] % k
Then (prefixSum[j] - prefixSum[i]) % k == 0
Meaning subarray from (i+1) to j is divisible by k
