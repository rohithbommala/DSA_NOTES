Problem Description

You are given two integers a and b (1 ≤ a ≤ b ≤ 10^18).
For every integer x in the range [a, b], compute the digit sum of x.
The digit sum of a number is the sum of all its digits.

Return the digit sum that occurs most frequently in the range [a, b], along with its frequency.
If there are multiple digit sums with the same maximum frequency, return the smallest digit sum.

class Solution {
private:
    // Memoization cache: dp[position][digitSum][isTight]
    long long dp[20][200][2];
    vector<int> digits;
    
    // Convert number to digit array
    vector<int> getDigits(long long num) {
        vector<int> result;
        if (num == 0) return {0};
        
        while (num > 0) {
            result.push_back(num % 10);
            num /= 10;
        }
        reverse(result.begin(), result.end());
        return result;
    }
    
    // Digit DP to count numbers with specific digit sum
    long long countNumbers(int pos, int sum, int tight, int targetSum) {
        // Base case
        if (pos == digits.size()) {
            return sum == targetSum ? 1 : 0;
        }
        
        // Check memoization
        if (dp[pos][sum][tight] != -1) {
            return dp[pos][sum][tight];
        }
        
        int limit = tight ? digits[pos] : 9;
        long long result = 0;
        
        // Try all possible digits at current position
        for (int digit = 0; digit <= limit && sum + digit <= targetSum; digit++) {
            int newTight = tight && (digit == limit);
            result += countNumbers(pos + 1, sum + digit, newTight, targetSum);
        }
        
        return dp[pos][sum][tight] = result;
    }
    
    // Count numbers in [0, n] with digit sum = targetSum
    long long countWithSum(long long n, int targetSum) {
        if (n < 0) return 0;
        
        digits = getDigits(n);
        memset(dp, -1, sizeof(dp));
        return countNumbers(0, 0, 1, targetSum);
    }
    
public:
    pair<int, long long> findMostFrequentDigitSum(long long a, long long b) {
        int maxSum = -1;
        long long maxFrequency = 0;
        
        // Maximum possible digit sum for 10^18 is 18*9 = 162
        for (int sum = 1; sum <= 162; sum++) {
            long long frequency = countWithSum(b, sum) - countWithSum(a - 1, sum);
            
            if (frequency > maxFrequency) {
                maxFrequency = frequency;
                maxSum = sum;
            }
        }
        
        return {maxSum, maxFrequency};
    }
};


📌 Example:

Let’s count numbers ≤ 23 whose digit sum = 5.

digits = [2, 3] (two-digit number).

Call → countNumbers(0, 0, 1, 5)

🔎 Step-by-Step Analysis
1. pos=0, sum=0, tight=1

Current digit in digits = 2

Since tight=1, limit = 2.

Try digits {0,1,2} at this position.

Case A: digit = 0

newTight = 0 (because 0 < 2).

Recurse → countNumbers(1, 0, 0, 5)

Inside Case A: pos=1, sum=0, tight=0

Limit = 9 (free choice).

Try digits {0..5} (since sum+digit ≤ 5).

👉 Valid completions: digit=5 → sum=5 ✅

So 1 valid number: 05 (leading zero allowed internally, represents “5”).

Case B: digit = 1

newTight = 0 (1 < 2).

Recurse → countNumbers(1, 1, 0, 5)

Inside Case B: pos=1, sum=1, tight=0

Limit = 9.

Need sum+digit=5.

So digit=4 works → number 14.

✅ 1 valid number.

Case C: digit = 2

newTight = 1 (equal to limit).

Recurse → countNumbers(1, 2, 1, 5)

Inside Case C: pos=1, sum=2, tight=1

Limit = digits[1] = 3.

Need sum+digit=5.

So digit=3 works → number 23.

✅ 1 valid number.

📌 Base Case

At each branch, when pos == digits.size(), check if sum == targetSum.

If yes → return 1.

Else → return 0.

✅ Final Result

Valid numbers ≤ 23 with digit sum = 5:

5

14

23

So function returns 3.
