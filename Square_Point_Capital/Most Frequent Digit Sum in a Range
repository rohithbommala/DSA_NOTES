Problem Description

You are given two integers a and b (1 â‰¤ a â‰¤ b â‰¤ 10^18).
For every integer x in the range [a, b], compute the digit sum of x.
The digit sum of a number is the sum of all its digits.

Return the digit sum that occurs most frequently in the range [a, b], along with its frequency.
If there are multiple digit sums with the same maximum frequency, return the smallest digit sum.

class Solution {
private:
    // Memoization cache: dp[position][digitSum][isTight]
    long long dp[20][200][2];
    vector<int> digits;
    
    // Convert number to digit array
    vector<int> getDigits(long long num) {
        vector<int> result;
        if (num == 0) return {0};
        
        while (num > 0) {
            result.push_back(num % 10);
            num /= 10;
        }
        reverse(result.begin(), result.end());
        return result;
    }
    
    // Digit DP to count numbers with specific digit sum
    long long countNumbers(int pos, int sum, int tight, int targetSum) {
        // Base case
        if (pos == digits.size()) {
            return sum == targetSum ? 1 : 0;
        }
        
        // Check memoization
        if (dp[pos][sum][tight] != -1) {
            return dp[pos][sum][tight];
        }
        
        int limit = tight ? digits[pos] : 9;
        long long result = 0;
        
        // Try all possible digits at current position
        for (int digit = 0; digit <= limit && sum + digit <= targetSum; digit++) {
            int newTight = tight && (digit == limit);
            result += countNumbers(pos + 1, sum + digit, newTight, targetSum);
        }
        
        return dp[pos][sum][tight] = result;
    }
    
    // Count numbers in [0, n] with digit sum = targetSum
    long long countWithSum(long long n, int targetSum) {
        if (n < 0) return 0;
        
        digits = getDigits(n);
        memset(dp, -1, sizeof(dp));
        return countNumbers(0, 0, 1, targetSum);
    }
    
public:
    pair<int, long long> findMostFrequentDigitSum(long long a, long long b) {
        int maxSum = -1;
        long long maxFrequency = 0;
        
        // Maximum possible digit sum for 10^18 is 18*9 = 162
        for (int sum = 1; sum <= 162; sum++) {
            long long frequency = countWithSum(b, sum) - countWithSum(a - 1, sum);
            
            if (frequency > maxFrequency) {
                maxFrequency = frequency;
                maxSum = sum;
            }
        }
        
        return {maxSum, maxFrequency};
    }
};


ðŸ“Œ Example:

Letâ€™s count numbers â‰¤ 23 whose digit sum = 5.

digits = [2, 3] (two-digit number).

Call â†’ countNumbers(0, 0, 1, 5)

ðŸ”Ž Step-by-Step Analysis
1. pos=0, sum=0, tight=1

Current digit in digits = 2

Since tight=1, limit = 2.

Try digits {0,1,2} at this position.

Case A: digit = 0

newTight = 0 (because 0 < 2).

Recurse â†’ countNumbers(1, 0, 0, 5)

Inside Case A: pos=1, sum=0, tight=0

Limit = 9 (free choice).

Try digits {0..5} (since sum+digit â‰¤ 5).

ðŸ‘‰ Valid completions: digit=5 â†’ sum=5 âœ…

So 1 valid number: 05 (leading zero allowed internally, represents â€œ5â€).

Case B: digit = 1

newTight = 0 (1 < 2).

Recurse â†’ countNumbers(1, 1, 0, 5)

Inside Case B: pos=1, sum=1, tight=0

Limit = 9.

Need sum+digit=5.

So digit=4 works â†’ number 14.

âœ… 1 valid number.

Case C: digit = 2

newTight = 1 (equal to limit).

Recurse â†’ countNumbers(1, 2, 1, 5)

Inside Case C: pos=1, sum=2, tight=1

Limit = digits[1] = 3.

Need sum+digit=5.

So digit=3 works â†’ number 23.

âœ… 1 valid number.

ðŸ“Œ Base Case

At each branch, when pos == digits.size(), check if sum == targetSum.

If yes â†’ return 1.

Else â†’ return 0.

âœ… Final Result

Valid numbers â‰¤ 23 with digit sum = 5:

5

14

23

So function returns 3.
